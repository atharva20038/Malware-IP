import os
from typing import List, Tuple

import numpy as np
from pandas import read_csv
import pandas as pd
from sklearn.model_selection import train_test_split


TrainTestData = Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]
TrainTestValData = Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]


def get_behaviour_data(no_rows, X_train, y_train, X_test, y_test, X_val, y_val):
    x_train = []
    x_test = []
    x_val = []
    for i in range(no_rows+1):
        if i != no_rows:
            x_train.append(X_train[i: -no_rows+i, :])
            x_test.append(X_test[i: -no_rows+i, :])
            x_val.append(X_val[i: -no_rows+i, :])
        else:
            x_train.append(X_train[i:, :])
            x_test.append(X_test[i:, :])
            x_val.append(X_val[i:, :])

    X_train = np.column_stack(tuple(x_train))
    X_test = np.column_stack(tuple(x_test))
    X_val = np.column_stack(tuple(x_val))
    y_test = y_test[:-no_rows]
    y_train = y_train[:-no_rows]
    y_val = y_val[:-no_rows]

    return X_train, y_train, X_test, y_test, X_val, y_val


def load_csv(fp_train: str, fp_test: str, label_col: str, drop_cols: List[str], normalization: bool = False) -> TrainTestData:
    """
    Loads any csv-file from local filepaths. Returns X and y for both train and test datasets.
    Option to normalize the data with min-max normalization.
    Only csv-files with float32 values for the features and int32 values for the labels supported.
    Source for dataset: https://mimic-iv.mit.edu/

    :param fp_train: Location of the train csv-file
    :type  fp_train: str
    :param fp_test: Location of the test csv-file
    :type  fp_test: str
    :param label_col: The name of the column containing the labels of the data
    :rtype label_col: str
    :param drop_cols: List of the names of the columns to be dropped. `label_col` gets dropped automatically
    :rtype drop_cols: List of strings
    :param normalization: Normalize the data with min-max normalization?
    :type  normalization: bool

    :return: Tuple of (X_train, y_train, X_test, y_test) containing original split of train/test
    :rtype: Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]
    """
    if not os.path.isfile(fp_train):
        raise FileNotFoundError(f"`fp_train` {fp_train} does not exist.")
    if not os.path.isfile(fp_test):
        raise FileNotFoundError(f"`fp_test` {fp_test} does not exist.")
    if not isinstance(normalization, bool):
        raise TypeError(f"`normalization` must be of type `bool`, not {type(normalization)}")
    
    X_train = pd.read_csv(fp_train)  
    X_test = pd.read_csv(fp_test)

    X_train.drop(columns=drop_cols, inplace=True)  # Dropping cols 
    X_test.drop(columns=drop_cols, inplace=True)

    X_train.dropna(inplace=True)
    X_test.dropna(inplace=True)

    y_train = X_train[label_col].astype(np.int32)
    y_test = X_test[label_col].astype(np.int32)
    X_train.drop(columns=[label_col], inplace=True) # Dropping label column
    X_test.drop(columns=[label_col], inplace=True)
    
    X_train = X_train.astype(np.float32) # DataFrames directly converted to float32
    X_test = X_test.astype(np.float32)

    # Other data sources are already normalized. RGB values are always in range 0 to 255.
    if normalization:
        mini, maxi = X_train.min(axis=0), X_train.max(axis=0)
        X_train -= mini
        X_train /= maxi - mini
        X_test -= mini
        X_test /= maxi - mini

    return X_train.values, y_train.values, X_test.values, y_test.values  # Numpy arrays


def get_train_test_val(X_train: np.ndarray, y_train: np.ndarray, X_test: np.ndarray, y_test: np.ndarray,
                       val_frac: float = 0.25,
                       print_stats: bool = True) -> TrainTestValData:
    """
    Divides the data into train, test and validation sets.
    
    :param X_train: The X_train data
    :type  X_train: np.ndarray
    :param y_train: The y_train data
    :type  y_train: np.ndarray
    :param X_test: The X_test data
    :type  X_test: np.ndarray
    :param y_test: The y_test data
    :type  y_test: np.ndarray
    :param val_frac: Fraction to take from X_train and y_train for X_val and y_val
    :type  val_frac: float
    :param print_stats: Print the imbalance ratio of the imbalanced data?
    :type  print_stats: bool

    :return: Tuple of (X_train, y_train, X_test, y_test, X_val, y_val)
    :rtype: Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]
    """
    if not 0 < val_frac < 1:
        raise ValueError(f"{val_frac} is not in interval 0 < x < 1.")
    if not isinstance(print_stats, bool):
        raise TypeError(f"`print_stats` must be of type `bool`, not {type(print_stats)}.")

    X_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=val_frac, stratify=y_train)

    return X_train, y_train, X_test, y_test, X_val, y_val
